const BASE = "http://localhost:5000/api/v1.0/";
const ID_KEY = "identity";

/**
 * @brief enroll user in system
 * @param lts_id LTS unique id
 * @param success function returns the secret generated by backend
 * @param error function returns any error result
 */
function enroll(lts_id, success, error) {
    const payload = {
        'lts_id' : lts_id,
        'secret' : ''
    };
    $.ajax({
        type: 'POST',
        url: BASE + 'enroll?' + $.param(payload),
        success: function (data) {
            console.debug("Secret: " + JSON.stringify(data));
            success(data);
        },
        error: function (data) {
            error(data);
        }
    });
}

/**
 * @brief Fetch the stats of specified user
 * @param student_id LTS unique id for user
 * @param secret authorization token to prevent impersonation
 * @param success callback receives fetched data
 * @param err callback receives raw ajax error
 * @param complete called always on completion
 */
function fetchStats(student_id, secret, success, err, complete) {
    scrapeCoursePageInfo(function(courseInfo) {
        const payload = {
            'lts_id': student_id,
            'secret': secret,
            'course_id': courseInfo['courseid']
        };
        $.ajax({
            type: 'GET',
            url: BASE + 'stats?' + $.param(payload),
            success: function (data) {
                success(data);
            },
            error: function (data) {
                err(data);
            },
            complete: function () {
                complete();
            }
        });
    });
}

/**
 * @brief Send course info to server, we don't care what happens
 * @param student_id for auth
 * @param secret for auth
 */
function addCourse(student_id, secret) {
    scrapeCoursePageInfo(function(courseInfo) {
        const payload = {
            'lts_id' : student_id,
            'secret' : secret,
            'course_id' : courseInfo['courseid'],
            'course_name' : courseInfo['coursename']
        };
        $.ajax({
            type: 'POST',
            url: BASE + 'addcourse?' + $.param(payload)
        });
    });
}

/**
 * @brief Build an HTML data containing stats data
 * @param classes dictionary containing stats
 * @returns {*|jQuery|HTMLElement}
 */
function makeOverviewTable(classes) {

    var $table = $('<table/>');
    $table.append('<tr>' +
    '<th> Course </th>' +
    '<th> Today </th>' +
    '<th> This Week </th>' +
    '<th> Last Week </th>' +
    '<th> All Time </th>' +
    '</tr>');
    $table.addClass('bordered');

    for(const k in classes){
        if(!classes.hasOwnProperty(k))
        {
            continue;
        }

        var data = classes[k];

        $table.append( '<tr>' +
            '<td>' + k + '</td>' +
            '<td>' + data.today_posts + '</td>' +
            '<td>' + data.this_week_posts + '</td>' +
            '<td>' + data.prev_week_posts + '</td>' +
            '<td>' + data.total_posts + '</td>' +
            '</tr>');
    }
    return $table;
}

/**
 * @brief hand rolled labels
 * @see https://github.com/chartjs/Chart.js/blob/master/src/controllers/controller.doughnut.js#L40
 * @param chart char.js object
 * @returns {*}
 */
function charLabelGen(chart) {
    var data = chart.data;
    if (data.labels.length && data.datasets.length) {
        return data.labels.map(function (label, i) {
            var meta = chart.getDatasetMeta(0);
            var ds = data.datasets[0];
            var arc = meta.data[i];
            var custom = arc && arc.custom || {};
            var getValueAtIndexOrDefault = Chart.helpers.getValueAtIndexOrDefault;
            var arcOpts = chart.options.elements.arc;
            var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
            var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
            var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
            var value = chart.config.data.datasets[arc._datasetIndex].data[arc._index];

            return {
                text: label + " : " + value,
                fillStyle: fill,
                strokeStyle: stroke,
                lineWidth: bw,
                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                index: i
            };
        });
    } else {
        return [];
    }
}

/**
 * @brief Generate a pretty pie chart
 * @param data list of 7 numbers to plot
 * @param ctx HTML canvas handle
 */
function makePieChart(data, ctx) {
    var backgroundColors = [
                'rgba(84,48,5, 0.9)',
                'rgba(140,81,10, 0.9)',
                'rgba(191,129,45, 0.9)',
                'rgba(223,194,125, 0.9)',
                'rgba(128,205,193, 0.9)',
                'rgba(53,151,143, 0.9)',
                'rgba(1,102,94, 0.9)'
            ];
    var options = {
        cutoutPercentage: 50,
        legend : {
            position : 'left',
            labels: {
                generateLabels : charLabelGen
            }
        },
        animation : {
            easing : 'easeInBounce'
        }
    };
    var pieData = {
        labels: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
        datasets: [{
            label: 'Posts by Day',
            data: data.weekday_posts_list,
            backgroundColor: backgroundColors
        }]
    };

    new Chart(ctx, {
        type: 'pie',
        data: pieData,
        options: options
    });

}

/**
 * @brief Generate a sub-table for the minutia of patterns
 * @param data to parse
 * @return HTML table
 */
function makeSubTable(data) {
 var $table = $('<table>');
    $table.append('<tr>' +
    '<th> Characteristic </th>' +
    '<th> Assessment </th>' +
    '</tr>');
    $table.addClass('bordered');
    var avg_len = data.total_words_posted / data.total_posts;
    $table.append('<tr><td>Avg. Words Per Post</td><td>'+ avg_len.toFixed(3) +'</td></tr>');
    $table.append('<tr><td>Avg. Days Between Posts</td><td>'+ data.days_apart_avg +'</td></tr>');
    $table.append('<tr><td>Avg. Objectivity</td><td>'+ data.obj_subj +'</td></tr>');
    $table.append('<tr><td>Favorite Day</td><td>'+ data.favorite_day +'</td></tr>');
    $table.append('</table>');
    return $table;
}

/**
 * @brief Build an HTML div containing pattern data
 * @param classes dictionary containing stats
 * @returns {*|jQuery|HTMLElement}
 */
function makePatternDiv(classes) {

    var $patternDiv = $('<div/>');

    var count = 0;
    for(const k in classes){

        if(!classes.hasOwnProperty(k))
        {
            continue;
        }

        var data = classes[k];

        var ctx = $('<canvas id="mmm-pie' + (count++) + '"></canvas>');

        $patternDiv.append( '<h6 class="center">' + k + '</h6>');
        $patternDiv.append(makeSubTable(data));
        $patternDiv.append(ctx);
        $patternDiv.append(makePieChart(data, ctx));
        $patternDiv.append('<div class="divider tall-divider"></div>');
    }
    return $patternDiv;
}

/**
 * @brief Create sentiment gradient div
 * @param data that contains stats
 * @param name of this section
 * @param index of this div from 0
 * @returns {string|*}
 */
function makeToneDiv(data, name, index) {
    sentiment ='<div>' +
            '<div class="row valign-wrapper">' +
              '<div class="col s3">' +
                '<span>' + name + '</span>' +
              '</div>'+
              '<div class="col s9">' +
                '<span class="black-text">' +
                   '<p>Highest Sentiment: ' + data.most_positive_date + '</p>' +
                   '<p>Lowest Sentiment: ' + data.most_negative_date + '</p>' +
                '</span>' +
              '</div>' +
            '</div>' +
            '<div class="tone-gradient' + index + ' row">' +
                '<div class="col s6"><h5 class="left-align text-overlay"></h5></div>' +
            '</div>' +
           '</div>';
    addStyleString('.tone-gradient' + index + ' { ' + data.sentiment_css + '}');
    return sentiment;
}

/**
 * @brief Handles fetching remote data and building out UI
 * @param identity Piazza identity string in format user|secret
 * @param err callback function receives raw AJAX error
 */
function renderData(identity, err) {

    // identity is in a string concat like id|secret
    const student_id = identity[ID_KEY].split('|')[0];
    const secret = identity[ID_KEY].split('|')[1];

    // We don't care if this fails, fire and forget
    addCourse(student_id, secret);

    // Creates data in sections so we're alternating which tabs are being written to
    // A little weird but it works
    fetchStats(student_id, secret, function (courseData) {

        // First build all the sentiment gradient divs
        var num = 0;
        var sent_container = $("#sentiment-container");
        for(const k in courseData){

            if(!courseData.hasOwnProperty(k))
            {
                continue;
            }

            var sent = makeToneDiv(courseData[k], k, num);
            sent_container.append(sent);
            ++num;
        }

        // If there is data, render it. Otherwise show the error message
        var engagement_header = $('#engagement-header');
        engagement_header.show();

        if(Object.keys(courseData).length > 0) {

            $('#engagement-container').append(makeOverviewTable(courseData));
            $('#pattern-container').append(makePatternDiv(courseData));

            engagement_header.empty().append('<span class="gray-text text-darken-2">Your Piazza Posts</span>');

        } else if (retry > 0) {

            console.info("Class data is not yet ready");
            engagement_header.empty().append('<span class="gray-text text-darken-2">Class data is not yet ready</span>');

        }
    }, err, function () {
        $('#spinner').hide();
    });
}

/**
 * @brief Identify the course by looking at the URL and tab name
 * @details this will fail if you are debugging so the else clause
 *  returns mock data. Fitting :)
 * @param callback to pass scraped info to
 */
function scrapeCoursePageInfo(callback) {

    // Pain in the ass way to get the tab title and URL
    chrome.tabs.query({'active': true, 'lastFocusedWindow': true}, function (tabs) {

        var activeTab = tabs[0];
        if (activeTab) {

            var title = activeTab.title;
            var url = activeTab.url;
            var courseName = title.split('(')[0];
            var courseId = url.split('/')[4];
            if (courseId.indexOf('?') >= 0) {
                courseId = courseId.split('?')[0];
            }

            console.debug("Course Info: " + courseName, courseId);
            callback({'coursename': courseName, 'courseid': courseId});

        } else {

            // I see you there on the debugger :)
            console.warn("Failed to get course data from current tab because you're on the debugger. Using mock data");
            callback({'coursename': 'OMS CS6460', 'courseid': 'j6azklk4gaf4v9'});

        }
    });
}

/**
 * @brief Get user id from Piazza token then go ask our backend
 * for a secret. This secret will be stored in Chrome storage
 * for future authorization
 * @param success callback function(string, callback)
 * @param error callback function(json data)
 */
function identifyUser(success, error) {

    // Piazza was kind enough to leave a cookie with our id!
    chrome.cookies.get({"url": "https://piazza.com", "name": "last_piaz_user"}, function (student_id) {

        // Go tell the server we're online and authenticate this ain't our first rodeo
        enroll(student_id.value, function (data) {

            var identity = {};
            identity[ID_KEY] = student_id.value + '|' + data['keep_this'];

            // Save this token in Chrome storage
            chrome.storage.sync.set(identity, function() {
                if(chrome.runtime.error) {
                    console.info("Failed to store identity");
                    error(chrome.runtime.error);
                } else {
                    success(identity, error);
                }
            });

        }, error);
    });
}

/**
 * @brief inject arbitrary css
 * @param str css to inject
 */
function addStyleString(str) {
    var node = document.createElement('style');
    node.innerHTML = str;
    document.body.appendChild(node);
}

/**
 * On DOM load, begin the authorization process. Once
 * authorized, trigger data fetch and render
 */
function initApp() {

    $('#spinner').show();

    // Common callback for all async functions that require an error handler
    function initErr(error) {
        $("#greeting").text("Ooops, something went wrong");
        console.log(JSON.stringify(error));
    }

    // Fetch user creds from Chrome storage
    chrome.storage.sync.get(ID_KEY, function(identity) {
        if (!chrome.runtime.error) {
            if(Object.keys(identity).length === 0) {
                console.debug("Creating new user");
                identifyUser(renderData, initErr);
            } else {
                console.debug("Using current identity");
                renderData(identity, initErr);
            }
        } else {
            // Plugin is effectively dead if this happens
            $("#greeting").text("Ooops, I couldn't retrieve your token");
            console.error(chrome.runtime.error);
        }
    });
}

/**
 * Entry point
 */
window.onload = function() {
    // TODO on uninstall we need to purge from our database somehow... hmm.
    //chrome.runtime.setUninstallURL(BASE);
    initApp()
};